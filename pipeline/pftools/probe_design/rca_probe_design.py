from Bio.SeqUtils import MeltingTemp
from Bio.Seq import Seq
from Bio.SeqUtils.MeltingTemp import Tm_NN, chem_correction
from tqdm import tqdm
import numpy as np
import pandas as pd
from collections import defaultdict
import pandas as pd
from typing import Tuple, List, Optional
from joblib import Parallel, delayed
import MERFISH_probe_design.IO.file_io as fio
import MERFISH_probe_design.probe_design.probe_dict as p_d
import MERFISH_probe_design.probe_design.OTTable_dict as ot
import MERFISH_probe_design.probe_design.readout_sequences as rs
import MERFISH_probe_design.probe_design.probe_selection as ps
import MERFISH_probe_design.probe_design.quality_check as qc
from MERFISH_probe_design.probe_design import filters
from pftools.probe_design.util import calc_tm, seqrc

from pftools.probe_design.util import *
from pftools.probe_design.base_probe_design import CombinatorialProbeDesigner


BAMHI_SITE = "ggatcc" # g^gatcc
ECORI_SITE_RC = "gaattc" # g^aattc reverse complement of ECORI
BCCI_SITE = "cgtatgatgg" 
BCCI_SITE_MIN = "gatgg"
BCIVI_SITE = "gtatccatgta" 
BCIVI_SITE_MIN = "gtatcc"

# Final RE split RCA primer is taCGACTTCAGCTGCTg + aattcTCCGAGTGAAGAGTta

PADLOCK_RCA_PRIMER_SPLIT_RE_THREEPRIME = "taCGACTTCAGCTGCT" + BAMHI_SITE 
PADLOCK_RCA_PRIMER_SPLIT_RE_FIVEPRIME = ECORI_SITE_RC  + "TCCGAGTGAAGAGTta" # capitalized is boloramis RCA primer site
PADLOCK_RCA_PRIMER = "taACTTCAGCTGCCCCGGGTGAAGAta" # capitalized is boloramis RCA primer site
#BCIVI_LEFT_RE = "CTTATCGTAgtatccatgtac" # has BciVI site
BCIVI_LEFT_RE = "gtatccatgtac" # has BciVI site
#BCCI_RIGHT_RE = "cgtatgatggcgaGATACGTA" # has BccI site
BCCI_RIGHT_RE = "cgtatgatggc" # has BccI site
# weights for splintr ligation efficiency
# Taken from: Efficient DNA ligation in DNAâ€“RNA hybrid helices by Chlorella virus DNA ligase, NAR (2014)
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3919565/

SPLINTR_SCORES = {"AT" : 10, "AA" : 29,   "AC" : 1, "AG" : 2,
            "CT" : 31,  "CA" : 25,  "CC" : 2, "CG" : -80,
            "TT" : 45,  "TA" : 219, "TC" : 11, "TG" : 5,
            "GT" : 20,  "GA" : 42,   "GC" : -100, "GG" : 0}

# DNAZyme at 3' end of staple should have P2 stem with final 8 bases of staple, followed by AC
# From: "Biotechnological mass production of DNA origami" https://www.nature.com/articles/nature24650

P1A_THREEPRIME_DNAZYME = "ACGTTGAAGCGTTACCTGTTAGGTAACGTAGTTGAGCTGT" # cut site is  ACGTTGA^AGCGTTACCTGTTAGGTAACGTAGTTGAGCTGT
P2B_FIVEPRIME_DNAZYME = "TAGTTGAGCTGTCACAGAATGTGACGTTGAAG" # cut site is TAGTTGAGCTGTCACAGAATGTGACGTTGA^AG
# Staple pseudogenes were generated by interleaving the individual staple sequences with the DNAzyme cassette ACGTTGAAGCGTTACCTGTTAGGTAACGTAGTTGAGCTGT-X8-TTTTT-Y8-TAGTTGAGCTGTCACAGAATGTGACGTTGAAG, 
# in which X8 represents 8 bases that are complementary to the last 8 bases of the upstream staple sequence and Y8 represents 8 bases that are complementary to the first 8 bases of the downstream staple.
RCA_SPLIT_THREEPRIME_DNAZYME_PRIMER ="CGACTTCA" + P1A_THREEPRIME_DNAZYME + seqrc("CGACTTCA")
RCA_SPLIT_FIVEPRIME_DNAZYME_PRIMER = seqrc("TCCGAGTG") + P2B_FIVEPRIME_DNAZYME + "TCCGAGTGAAGAGCTta"

# Final padlock RCA primer sequence should be:
# CGACTTCAACGTTGA - AGTCCGAGTGAAGAGCTta

# From "Catalytic DNA-assisted mass production of arbitrary single-stranded DNA" 
# https://onlinelibrary.wiley.com/doi/10.1002/anie.202212011
def design_dnazyme_primers_for_probe(probe_seq:str) -> Tuple[str, str]:
    """
    Design DNAzyme cleavage sequences for probe on 5' and 3' ends. 
    """
    probe_seq = probe_seq.upper()
    final_base = probe_seq[-1]

    probe_start = probe_seq[1:15]
    probe_end = probe_seq[-15:]

    # if T use II-R3
    # GGTAACGAACGTAGT^AGTATCTTTTGCGTACAATCCGACGCGTCGGATTGTAAGCTAGGGGAATAAATCTTTGGGTGACTACGTTCGTTACC
    # design 3' primer
    if final_base == 'T':
        threeprime = "AGTATCTTTTGCGTACAATCCGACGCGTCGGATTGTAAGCTAGGGGAATAAATCTTTGGGTG" + seqrc(probe_end)
    # otherwise use II-R2
    # GGTAACGAACGTAGG^AGCATCTTAGTAGTACAATCCGACGCGTCGGATTGTACGATTGGGGAATAGATCTTTGGGACCCTACGTTCGTTACC
    else:
        threeprime = "AGCATCTTAGTAGTACAATCCGACGCGTCGGATTGTACGATTGGGGAATAGATCTTTGGGAC" + seqrc(probe_end)
    
    # design 5' primer
    fiveprime = seqrc(probe_start) + "TATACCGGGCAACTATTGCCTCGTCATCGCTATTTTCTGCGATAGTGAGTCGTATTATTTTAATACGACTCACTATACTGC" # use the last 14 bases of the probe start
    return fiveprime.lower(), threeprime.lower()

class SplintrProbeDesigner(CombinatorialProbeDesigner):
    def __init__(self, codebook_path:str, bit_sequences_path:str, transcriptome_path:str, 
                 transcriptome_ottable_path:str, ncrna_ottable_path:str, 
                 extra_seq_path:str=None,
                 verbose:bool=True, 
                 n_probes_per_transcript:int=8, 
                 ncrna_k:int=15, 
                 mrna_k:int=17,
                 offtarget_ncrna_upper_bound:float=0.5, 
                 offtarget_mrna_upper_bound:float=75, n_threads=-1):

        # initialize super class
        super().__init__(codebook_path, bit_sequences_path, transcriptome_path, 
                            transcriptome_ottable_path, ncrna_ottable_path,
                            extra_seq_path=extra_seq_path,
                            verbose=verbose,
                            n_probes_per_transcript=n_probes_per_transcript,
                            ncrna_k=ncrna_k,
                            mrna_k=mrna_k,
                            offtarget_ncrna_upper_bound=offtarget_ncrna_upper_bound,
                            offtarget_mrna_upper_bound=offtarget_mrna_upper_bound,
                            n_threads=n_threads)

    def _init_probe_dict(self, pb_len_left:int, pb_len_right:int, overlap:int=1):
        super()._init_probe_dict(pb_len_left + pb_len_right, overlap=overlap)

    def design_probes_for_genes(self, pb_len_left:int, pb_len_right:int,
                                       gc_range:List[float]=[25, 75], 
                                       tm_range:List[float]=[66, 76], 
                                       na_conc_molar:float=0.3, 
                                       ligate_min_tm:float=25,
                                       hyb_fmd:float=30, 
                                       hyb_min_tm:float=46,
                                       overlap:int=1):
        
        def _find_split_helper(idx, s):
            # NOTE THAT THESE ARE BACKWARDS FROM WHAT MIGHT BE EXPCTED
            best_score, (right_pb, left_pb) = find_best_padlock_split(s, midpoint=pb_len_left, ligate_min_tm=ligate_min_tm, hyb_na=na_conc_molar*1000, hyb_fmd=hyb_fmd, hyb_min_tm=hyb_min_tm, verbose=False, symmetric=symmetric)
            return idx, best_score, left_pb, right_pb

        symmetric = pb_len_left == pb_len_right

        self._init_probe_dict(pb_len_left, pb_len_right, overlap=overlap)
        # split the probes -- giving reverse complemented probes
        used_bits = self._get_all_used_bits()
        for gk in tqdm(self._probe_dict.keys()):
            for tk in self._probe_dict[gk].keys():
                curr_df = self._probe_dict[gk][tk]
                left_pbs = []
                right_pbs = []
                seqs = curr_df['target_sequence'].tolist()
                # screen out sequences that hybridize to readouts (exact match on either strand)
                seqs = [s for s in seqs if not screen_for_bit_binding(s, used_bits)] 
                split_seqs = Parallel(n_jobs=self._n_threads)(delayed(_find_split_helper)(i,seqs[i]) for i in range(len(seqs)))

                to_drop = []
                for i, best_score, left_probe, right_probe in split_seqs:
                    if best_score != -1:
                        left_pbs.append(left_probe)
                        right_pbs.append(right_probe)
                    else: # remove this probe
                        to_drop.append(i)
                curr_df = curr_df.drop(to_drop)
                curr_df['target_sequence_rc_left'] = left_pbs
                curr_df['target_sequence_rc_right'] = right_pbs
                self._probe_dict[gk][tk] = curr_df

        filter_probe_dict(self._probe_dict, "target_sequence_rc_right", 
                        self._ncrna_ottable, self._transcriptome_ottable,
                        gc_range=gc_range, tm_range=tm_range, ncrna_k=self._ncrna_k,
                        offtarget_ncrna_upper_bound=self._offtarget_ncrna_upper_bound,
                        mrna_k=self._mrna_k, off_target_mrna_upper_bound=self._offtarget_mrna_upper_bound,
                        na_conc_molar=na_conc_molar, write_prefix='target_sequence_rc_right')

        if self._extra_seqs is not None:
            ot.calc_OTs(self._probe_dict, self._extra_seqs_ottable, 'target_sequence_rc_right', 'target_sequence_rc_right_OT_extra', self._mrna_k)
            filters.filter_probe_dict_by_metric(self._probe_dict, 'target_sequence_rc_right_OT_extra', upper_bound=self._offtarget_mrna_upper_bound)


        if symmetric:
            # if the probes are asymmetric, only filter based on right half
            filter_probe_dict(self._probe_dict, "target_sequence_rc_left", 
                            self._ncrna_ottable, self._transcriptome_ottable,
                            gc_range=gc_range, tm_range=tm_range, ncrna_k=self._ncrna_k,
                            offtarget_ncrna_upper_bound=self._offtarget_ncrna_upper_bound,
                            mrna_k=self._mrna_k, off_target_mrna_upper_bound=self._offtarget_mrna_upper_bound,
                            na_conc_molar=na_conc_molar, write_prefix='target_sequence_rc_left')

            if self._extra_seqs is not None:
                ot.calc_OTs(self._probe_dict, self._extra_seqs_ottable, 'target_sequence_rc_left', 'target_sequence_rc_left_OT_extra', self._mrna_k)
                filters.filter_probe_dict_by_metric(self._probe_dict, 'target_sequence_rc_left_OT_extra', upper_bound=self._offtarget_mrna_upper_bound)


    def add_bits_to_probes(self, bit_revcomp=True, spacer='t', split:bool=False):
        # Each probe will get all bits in the codebook
        # iterate over genes
        for gk in self._probe_dict.keys():
            # get bits
            curr_bits = self._get_bits_from_codebook_for_gene(gk)
            for tk in self._probe_dict[gk].keys():
                curr_pd = self._probe_dict[gk][tk]
                splintr_pbs = []
                for (seq_left, seq_right) in zip(curr_pd['target_sequence_rc_left'], curr_pd['target_sequence_rc_right']):
                    splintr_pbs.append(self._construct_splintr_probe(seq_left, seq_right, curr_bits, spacer=spacer, bit_revcomp=bit_revcomp, split=split))
                self._probe_dict[gk][tk]['splintr_probe'] = pd.Series(splintr_pbs, index=curr_pd.index)

        ot.calc_OTs(self._probe_dict, self._ncrna_ottable, 'splintr_probe', 'splintr_probe_OT_ncrna', self._ncrna_k)
        filters.filter_probe_dict_by_metric(self._probe_dict, 'splintr_probe_OT_ncrna', upper_bound=self._offtarget_ncrna_upper_bound)

        
    def add_primers_to_probes(self, forward_primer_rc:str, reverse_primer:str, subsample_probes:bool=True, use_dnazyme:bool=False, split:bool=False, 
                              reverse_primer_lhs:Optional[str]=None, forward_primer_rhs:Optional[str]=None):
        # filter out probes with Type IIS restriction sites 
        if use_dnazyme:
            self._add_dnazyme_to_probes(forward_primer_rc, reverse_primer, subsample_probes=subsample_probes, input_column='splintr_probe', output_column='splintr_probe_with_primers', split=split, reverse_primer_lhs=reverse_primer_lhs, forward_primer_rhs=forward_primer_rhs)

            if subsample_probes:
                print(f"RANDOMLY SUBSAMPLING {self._n_probes_per_transcript} PROBES!!")
                select_probes_greedy_stochastic_nobits(self._probe_dict, self._n_probes_per_transcript)
        else:
            filter_probe_dict_by_fn(self._probe_dict, screen_for_typeiis_sites, 'splintr_probe', 'has_re_site')
            forward_primer_rc_with_re = forward_primer_rc + BCIVI_LEFT_RE
            reverse_primer_with_re = BCCI_RIGHT_RE + reverse_primer 
            super().add_primers_to_probes(forward_primer_rc_with_re, reverse_primer_with_re, 
                                        subsample_probes=subsample_probes, input_column='splintr_probe', output_column='splintr_probe_with_primers') 
            if split:
                # iterate through probes and add in split RE sites
                print("ADDING SPLIT RE SITES TO PROBES")
                for gk in self._probe_dict.keys():
                    for tk in self._probe_dict[gk].keys():
                        output_seqs = []

                        for seq in self._probe_dict[gk][tk]['splintr_probe_with_primers']:
                            lhs, rhs = seq.split('.')
                            output_seqs.append(lhs + PADLOCK_RCA_PRIMER_SPLIT_RE_THREEPRIME + reverse_primer_lhs + '.' + forward_primer_rhs + PADLOCK_RCA_PRIMER_SPLIT_RE_FIVEPRIME + rhs)

                        self._probe_dict[gk][tk]['splintr_probe_with_primers'] = pd.Series(output_seqs, index=self._probe_dict[gk][tk].index)

        
    def _add_dnazyme_to_probes(self, forward_primer_rc:str, reverse_primer:str, subsample_probes:bool=True, split:bool=False, input_column:str='splintr_probe', 
                               output_column:str='splintr_probe_with_primers', reverse_primer_lhs:Optional[str]=None, forward_primer_rhs:Optional[str]=None):
        # subsample first for speed
        if subsample_probes:
            select_probes_greedy_stochastic_nobits(self._probe_dict, self._n_probes_per_transcript)

        new_pb_dict = {}
        for gk in self._probe_dict.keys():
            for tk in self._probe_dict[gk].keys():
                curr_df = self._probe_dict[gk][tk]
                if curr_df.shape[0] > 0:
                    if gk not in new_pb_dict:
                        new_pb_dict[gk] = {}
                    new_pb_dict[gk][tk] = curr_df
                else:
                    print("Found 0 probes for gene", gk, "transcript", tk, ". Removing gene from probe dict.")

        self._probe_dict = new_pb_dict
        for gk in self._probe_dict.keys():
            for tk in self._probe_dict[gk].keys():
                output_seqs = []

                for seq in self._probe_dict[gk][tk][input_column]:
                    # design primers for this probe
                    fiveprimer_dnazyme, threeprime_dnazyme = design_dnazyme_primers_for_probe(seq)
                    if split:
                        lhs, rhs = seq.split('.')
                        output_seqs.append(forward_primer_rc + fiveprimer_dnazyme + lhs + RCA_SPLIT_THREEPRIME_DNAZYME_PRIMER + reverse_primer_lhs + '.' + forward_primer_rhs + RCA_SPLIT_FIVEPRIME_DNAZYME_PRIMER + rhs + threeprime_dnazyme + reverse_primer)
                    else:
                        output_seqs.append(forward_primer_rc  + fiveprimer_dnazyme + seq + threeprime_dnazyme + reverse_primer)

                self._probe_dict[gk][tk][output_column] = pd.Series(output_seqs, index=self._probe_dict[gk][tk].index)

    def _get_all_used_bits(self) -> List[str]:
        """
        Get all the bits that are used in the probes.
        """
        all_bits = []
        for gk in self._probe_dict.keys():
            curr_bits = self._get_bits_from_codebook_for_gene(gk)
            all_bits.extend(curr_bits)
        return list(set(all_bits))


    def _get_bits_from_codebook_for_gene(self, gene_name:str) -> List[str]:
        """
        Get the bits from the codebook for a given gene. Assume that the binary strings can index the bits directly.
        """
        # get the barcode_str from the codebook
        barcode_str = self._codebook.loc[self._codebook['name'] == gene_name, 'barcode_str'].iloc[0]

        # get the bits from the barcode_str
        # NOTE: This assumes that the bits are in the same order as the binary strings, and that the binary strings can index the bits directly
        bits = []
        for i in range(len(barcode_str)):
            if barcode_str[i] == '1':
                # get the name of this bit
                bit_name = self._bit_names[i]
                # find the bit sequence associated with that name
                bits.append(self._bits[self._bits['bit_name']==bit_name]['bit_sequence'].iloc[0])
        return bits
    
    def _construct_splintr_probe(self, left_probe:str, right_probe:str, bits:List[str], spacer:str='t', bit_revcomp:bool=True, split:bool=False) -> str:
        """
        Construct a SplintR probe from two halves and a list of bits.
        """
        if split:
            # shuffle the bits and put half on one sides of the RCA primer and half on the other
            shuffled_bits = list(np.array(bits)[np.random.permutation(len(bits))])
            if bit_revcomp:
                bits_with_spacer = [seqrc(b) + spacer for b in shuffled_bits]
            else:
                bits_with_spacer = [b + spacer for b in shuffled_bits]
            left_bits = "".join(bits_with_spacer[:len(bits)//2])
            right_bits = "".join(bits_with_spacer[len(bits)//2:])
            return left_probe + left_bits + "." + right_bits + right_probe # use . as placeholder for splitting sequence
        else:
            if bit_revcomp:
                bits_with_spacer = [seqrc(b) + spacer for b in bits]
            else:
                bits_with_spacer = [b + spacer for b in bits]
            return left_probe + PADLOCK_RCA_PRIMER + "".join(bits_with_spacer) + right_probe

 
class FlexProbeDesigner(CombinatorialProbeDesigner):
    def __init__(self, gene_names_path:str, transcriptome_path:str, 
                 transcriptome_ottable_path:str, ncrna_ottable_path:str, 
                 extra_seq_path:str=None,
                 verbose:bool=True, 
                 n_probes_per_transcript:int=3, 
                 ncrna_k:int=15, 
                 mrna_k:int=17,
                 offtarget_ncrna_upper_bound:float=0.5, 
                 offtarget_mrna_upper_bound:float=75, n_threads=-1):
        # initialize super class
        super().__init__(None, None, transcriptome_path, 
                            transcriptome_ottable_path, ncrna_ottable_path,
                            extra_seq_path=extra_seq_path,
                            verbose=verbose,
                            n_probes_per_transcript=n_probes_per_transcript,
                            ncrna_k=ncrna_k,
                            mrna_k=mrna_k,
                            offtarget_ncrna_upper_bound=offtarget_ncrna_upper_bound,
                            offtarget_mrna_upper_bound=offtarget_mrna_upper_bound,
                            n_threads=n_threads)

        # needs to just have a column gene_short_name
        self._gene_list = pd.read_csv(gene_names_path)['gene_short_name']

    def _init_probe_dict(self, pb_len_left:int, pb_len_right:int, overlap:int=1):
        self._probe_dict = p_d.init_probe_dict(self._gene_list, self._transcriptome, 'gene_short_name', K=pb_len_left+pb_len_right, overlap=overlap)

    def design_probes_for_genes(self, pb_len_left:int, pb_len_right:int,
                                       gc_range:List[float]=[44, 72], 
                                       tm_range:List[float]=[61, 71], 
                                       na_conc_molar:float=0.3, 
                                       ligate_min_tm:float=25,
                                       hyb_fmd:float=10, 
                                       hyb_min_tm:float=46, 
                                       overlap:int=1,
                                       use_dnazyme:bool=False):
        
        def _find_split_helper(idx, s):
            # NOTE THAT THESE ARE BACKWARDS FROM WHAT MIGHT BE EXPCTED
            best_score, (left_pb, right_pb) = find_best_padlock_split(s, midpoint=pb_len_left, ligate_min_tm=ligate_min_tm, hyb_na=na_conc_molar*1000, hyb_fmd=hyb_fmd, hyb_min_tm=hyb_min_tm, verbose=False, symmetric=symmetric)
            return idx, best_score, left_pb, right_pb

        symmetric = pb_len_left == pb_len_right

        self._init_probe_dict(pb_len_left, pb_len_right, overlap=overlap)
        # split the probes -- giving reverse complemented probes
        for gk in tqdm(self._probe_dict.keys()):
            for tk in self._probe_dict[gk].keys():
                curr_df = self._probe_dict[gk][tk]
                left_pbs = []
                right_pbs = []
                seqs = curr_df['target_sequence'].tolist()
                # screen out sequences that hybridize to readouts (exact match on either strand)
                split_seqs = Parallel(n_jobs=self._n_threads)(delayed(_find_split_helper)(i,seqs[i]) for i in range(len(seqs)))

                to_drop = []
                for i, best_score, left_probe, right_probe in split_seqs:
                    if best_score != -1:
                        left_pbs.append(left_probe)
                        right_pbs.append(right_probe)
                    else: # remove this probe
                        to_drop.append(i)
                curr_df = curr_df.drop(to_drop)
                curr_df['target_sequence_rc_left'] = left_pbs
                curr_df['target_sequence_rc_right'] = right_pbs
                self._probe_dict[gk][tk] = curr_df

        filter_probe_dict(self._probe_dict, "target_sequence_rc_right", 
                        self._ncrna_ottable, self._transcriptome_ottable,
                        gc_range=gc_range, tm_range=tm_range, ncrna_k=self._ncrna_k,
                        offtarget_ncrna_upper_bound=self._offtarget_ncrna_upper_bound,
                        mrna_k=self._mrna_k, off_target_mrna_upper_bound=self._offtarget_mrna_upper_bound,
                        na_conc_molar=na_conc_molar, write_prefix='target_sequence_rc_right')

        if self._extra_seqs is not None:
            ot.calc_OTs(self._probe_dict, self._extra_seqs_ottable, 'target_sequence_rc_right', 'target_sequence_rc_right_OT_extra', self._mrna_k)
            filters.filter_probe_dict_by_metric(self._probe_dict, 'target_sequence_rc_right_OT_extra', upper_bound=self._offtarget_mrna_upper_bound)


        if symmetric:
            # if the probes are asymmetric, only filter based on right half
            filter_probe_dict(self._probe_dict, "target_sequence_rc_left", 
                            self._ncrna_ottable, self._transcriptome_ottable,
                            gc_range=gc_range, tm_range=tm_range, ncrna_k=self._ncrna_k,
                            offtarget_ncrna_upper_bound=self._offtarget_ncrna_upper_bound,
                            mrna_k=self._mrna_k, off_target_mrna_upper_bound=self._offtarget_mrna_upper_bound,
                            na_conc_molar=na_conc_molar, write_prefix='target_sequence_rc_left')

            if self._extra_seqs is not None:
                ot.calc_OTs(self._probe_dict, self._extra_seqs_ottable, 'target_sequence_rc_left', 'target_sequence_rc_left_OT_extra', self._mrna_k)
                filters.filter_probe_dict_by_metric(self._probe_dict, 'target_sequence_rc_left_OT_extra', upper_bound=self._offtarget_mrna_upper_bound)


        # construct the probes
        for gk in self._probe_dict.keys():
            # get bits
            for tk in self._probe_dict[gk].keys():
                curr_pd = self._probe_dict[gk][tk]
                flex_pbs = []
                for (seq_left, seq_right) in zip(curr_pd['target_sequence_rc_left'], curr_pd['target_sequence_rc_right']):
                    flex_pbs.append(self._construct_flex_probe(seq_left, seq_right, use_dnazyme=use_dnazyme))
                
                # add random 0, 1, 2, 3 bases on 5' end
                for i in range(len(flex_pbs)):
                    n_bases = np.random.randint(0,4)
                    addition = "".join(np.random.choice(['G','A','T','C'], size=n_bases)).lower()
                    flex_pbs[i] = addition + flex_pbs[i]
                self._probe_dict[gk][tk]['flex_probe'] = pd.Series(flex_pbs, index=curr_pd.index)

        ot.calc_OTs(self._probe_dict, self._ncrna_ottable, 'flex_probe', 'flex_probe_OT_ncrna', self._ncrna_k)
        filters.filter_probe_dict_by_metric(self._probe_dict, 'flex_probe_OT_ncrna', upper_bound=self._offtarget_ncrna_upper_bound)

    def add_bits_to_probes(self, bit_revcomp=True, spacer='t'):
        raise NotImplementedError("Flex probes do not have bits.")

    def add_primers_to_probes(self, subsample_probes: bool = True, split:bool=False, lhs_primer_fwd:Optional[str]=None, lhs_primer_rev:Optional[str]=None, 
                              rhs_primer_fwd:Optional[str]=None, rhs_primer_rev:Optional[str]=None, add_adaptor_through_pcr:Optional[bool]=False):
        lhs_probe = "GTGACTGGAGTTCAGACGTGTGCTCTTCCGATCT" # Using TruSeq 2, not  "CCTTGGCACCCGAGAATTCCA" which is illumina small RNA
        rhs_probe = "CGCCAAGTTC".lower() + "ACGCGGTTAGCACGTA" # use PCR to add probe barcode. First sequence is random to allow better PCR

        # greedily take probes starting from the 5' end to avoid overlaps
        select_probes_greedy_nooverlap(self._probe_dict)
        if add_adaptor_through_pcr:
            # don't add anything
            super().add_primers_to_probes("", "", 
                            subsample_probes=subsample_probes, input_column='flex_probe', output_column='flex_probe_with_primers')

        else:
            super().add_primers_to_probes(lhs_probe, rhs_probe, 
                                        subsample_probes=subsample_probes, input_column='flex_probe', output_column='flex_probe_with_primers')

        if split:
            # iterate through probes and add in split RE sites
            print("ADDING PCR PRIMERS TO SPLIT PROBES")
            for gk in self._probe_dict.keys():
                for tk in self._probe_dict[gk].keys():
                    output_seqs = []

                    for seq in self._probe_dict[gk][tk]['flex_probe_with_primers']:
                        lhs, rhs = seq.split('.')
                        output_seqs.append(lhs_primer_fwd + lhs + lhs_primer_rev + '.' + rhs_primer_fwd + rhs + rhs_primer_rev)

                    self._probe_dict[gk][tk]['flex_probe_with_primers'] = pd.Series(output_seqs, index=self._probe_dict[gk][tk].index)

    def _construct_flex_probe(self, seq_left:str, seq_right:str, use_dnazyme:bool=False, split:bool=True) -> str:
        """
        Construct a Flex probe from two halves.
        """
        if split:
            if use_dnazyme:
                fiveprimer_dnazyme, threeprime_dnazyme = design_dnazyme_primers_for_probe(seq_right + seq_left)
                return seq_left + threeprime_dnazyme + "." + fiveprimer_dnazyme + seq_right
            else:
                return seq_left + BCCI_RIGHT_RE + "." + BCIVI_LEFT_RE + seq_right
        else:
            if use_dnazyme:
                # design DNAzymes for sequences on both ends
                fiveprimer_dnazyme, threeprime_dnazyme = design_dnazyme_primers_for_probe(seq_right + seq_left)
                # use RCA primer just as intervening sequence
                return seq_left + threeprime_dnazyme + PADLOCK_RCA_PRIMER + fiveprimer_dnazyme + seq_right
            else:
                return seq_left + BCCI_RIGHT_RE + PADLOCK_RCA_PRIMER + BCIVI_LEFT_RE + seq_right

def select_probes_greedy_nooverlap(probe_dict:dict, N_threads:int=1):
    '''A greedy stochastic method to select probes.
    Arguments:
        probe_dict: The dictionary of probes.
    '''
    keys = []
    args = []
    results = []
    for gk in probe_dict.keys(): 
        for tk in probe_dict[gk].keys():
            keys.append((gk, tk))
            #args.append([probe_dict[gk][tk]]) 
            if probe_dict[gk][tk].shape[0] > 0:
                results.append(select_probes_greedy_nooverlap_one_df(probe_dict[gk][tk])) 
            else:
                results.append(probe_dict[gk][tk])
    #with Pool(N_threads) as p:
    #    results = p.starmap(select_probes_greedy_nooverlap_one_df, args)

    for i in range(len(keys)):
        gk, tk = keys[i]
        probe_dict[gk][tk] = results[i]

# select probes trying to make as even as possible
def select_probes_greedy_nooverlap_one_df(df:pd.core.frame.DataFrame):
    """
    Greedily select all the probes that don't overlap with each other, starting from the first probe.
    """
    # Create a array to track the coverage of the transcript
    target_length = len(df.iloc[0]['target_sequence'])
    
    selected_indices = [0] # start with the first probe
    for i in range(1, df.shape[0]):
        if df.iloc[i]['shift'] >= df.iloc[selected_indices[-1]]['shift'] + target_length:
            selected_indices.append(i)
   
    # Return a data frame with the selected indices
    return df.iloc[selected_indices]


def screen_for_bit_binding(seq:str, bits:List[str]) -> bool:
    """
    Check if a probe (post ligation) contains any of the bits (exact match on either strand).
    Returns True if any of the bits are in the sequence, False otherwise.
    """
    bits = [b.lower() for b in bits]
    bits = bits + [seqrc(b).lower() for b in bits]
    bit_in_probe = [b in seq.lower() for b in bits]
    return any(bit_in_probe)

#
def screen_for_typeiis_sites(seq:str, re:List[str]=[BCCI_SITE, BCIVI_SITE]) -> bool:
    """
    Check if a sequence that can bind the primers used for Type IIs RE digestion.
    """
    seq = seq.lower()
    for r in re:
        if (r in seq) or (r in seqrc(seq)):
            return True
    return False

# For SplintR ligated probes 
# design padlocks for these bits
# split equally
def find_best_padlock_split(b:str, search_size:int=3, midpoint=None, ligate_min_tm=25, verbose=False, 
                            hyb_na=300, hyb_fmd=30, hyb_min_tm=46, symmetric=True, tm_diff_cutoff:float=5.0) -> Tuple[float, str]:
    """
    Splint SplintR probe into two halves, trying to optimize the ligation efficiency and ensure that both halves are above the minimum Tm
    Inputs:
        b: sequence to split
        search_size: how many bases to search around the midpoint
        midpoint: where to split the sequence
        ligate_min_tm: minimum Tm for ligation
        verbose: whether to print out Tm values
        hyb_na: Na concentration for hybridization
        hyb_fmd: formamide concentration for hybridization
        hyb_min_tm: minimum Tm for hybridization
        asymmetric: whether to require both halves to be above the minimum Tm
    Outputs:
        score: ligation efficiency score
        split: tuple of the two halves
    """
    b_rc = seqrc(b)
    if midpoint is None:
        midpoint = int(len(b)/2)
    curr_scores = []
    curr_splits = []
    curr_tm_diffs = []
    # search on search_size nucleotides around midpoint
    for i in range(-search_size,search_size+1):
        first = b_rc[:(midpoint+i)].upper()
        second = b_rc[(midpoint+i):].upper()
        score = SPLINTR_SCORES[first[-1]+second[0]] # seems backwards because second strand actually have 5' phos
        if verbose:
            print(first, second, first[-1]+second[0], score)

        # check that both arms are above the minimum Tm during ligation
        if calc_tm(first, Na=0, Mg=10) >= ligate_min_tm and calc_tm(second, Na=0, Mg=10) >= ligate_min_tm:
            if not symmetric:
                if calc_tm(first, Na=hyb_na, fmd=hyb_fmd) >= hyb_min_tm and calc_tm(second, Na=hyb_na, fmd=hyb_fmd) < hyb_min_tm:
                    curr_scores.append(score+np.abs(i))
                    curr_splits.append((first, second))
            else:
                tm_diff = np.abs(calc_tm(first, Na=hyb_na, fmd=hyb_fmd) - calc_tm(second, Na=hyb_na, fmd=hyb_fmd))
                if calc_tm(first, Na=hyb_na, fmd=hyb_fmd) >= hyb_min_tm and calc_tm(second, Na=hyb_na, fmd=hyb_fmd) >= hyb_min_tm:
                    curr_scores.append(score+np.abs(i))
                    curr_splits.append((first, second))
                    curr_tm_diffs.append(tm_diff)

    if len(curr_scores) == 0:
        # no good splits
        return -1, ("","")
    else:
        max_score_idx = np.argmax(curr_scores)
        if symmetric:
            # find best split with a Tm difference below the threshold
            if np.sum(np.array(curr_tm_diffs) <= tm_diff_cutoff) > 0: 
                valid_scores = np.max([curr_scores[i] for i in range(len(curr_scores)) if curr_tm_diffs[i] <= tm_diff_cutoff])
                max_score_idx = np.where(np.array(curr_scores) == valid_scores)[0][0]
            else:
                # splint the split with the smallest Tm difference
                max_score_idx = np.argmin(curr_tm_diffs)
        #best_split = curr_splits[max_score]
        if verbose:
            best_split = curr_splits[max_score_idx]
            print(curr_scores, curr_tm_diffs)
            print(max_score_idx, best_split)
            print("Left Tm Hyb: %0.01f; Right Hyb Tm: %0.01f" % (calc_tm(best_split[0], Na=hyb_na, fmd=hyb_fmd), calc_tm(best_split[1], Na=hyb_na, fmd=hyb_fmd)))
            print("Left Ligate Tm: %0.01f; Right Ligate Tm: %0.01f" % (calc_tm(best_split[0], Na=0, Mg=10), calc_tm(best_split[1], Na=0, Mg=10)))
        return curr_scores[max_score_idx], curr_splits[max_score_idx]

#
# Older code for specific situations
#
def design_splintr_probe_for_bc(bc_seq: str, bits:List[str], hyb_len:int=30, tm_diff_cutoff:float=5.0, abs_tm_cutoff:float=47.0, linker:str='ta') -> List[str]:
    """
    Design a SplintR probe for a barcode sequence, using equal length probes.
    Outputs probe that can be ordered from IDT.
    """
    pbs = []
    for i in range(0, len(bc_seq), 2*hyb_len):
        # get 60 mer sequence
        seq = bc_seq[i:(2*hyb_len + i)]
        # try to find good junctions
        score, (right_probe, left_probe) = find_best_padlock_split(seq)
        tm_diff = np.abs(calc_tm(left_probe) - calc_tm(right_probe))
        if tm_diff > tm_diff_cutoff:
            # check if naive split has more acceptable Tm
            naive_left = seqrc(seq[:hyb_len])
            naive_right = seqrc(seq[hyb_len:])
            if np.abs(calc_tm(naive_left) - calc_tm(naive_right)) < tm_diff:
                left_probe = naive_left
                right_probe = naive_right
                tm_diff = np.abs(calc_tm(left_probe) - calc_tm(right_probe))
        if calc_tm(left_probe) >= abs_tm_cutoff and calc_tm(right_probe) > abs_tm_cutoff and tm_diff <= tm_diff_cutoff:
            print(i, calc_tm(left_probe), calc_tm(right_probe))
            pbs.append("/5Phos/" + left_probe + PADLOCK_RCA_PRIMER + "".join(bits) + linker + right_probe)
    return pbs

def design_splintr_probe_with_blank(bc_seq: str, hyb_len:int=30, tm_diff_cutoff:float=5.0, abs_tm_cutoff:float=47.0, linker:str='ta') -> List[str]:
    pbs = []
    for i in range(0, len(bc_seq), 2*hyb_len):
        # get 60 mer sequence
        seq = bc_seq[i:(2*hyb_len + i)]
        # try to find good junctions
        score, (right_probe, left_probe) = find_best_padlock_split(seq)
        tm_diff = np.abs(calc_tm(left_probe) - calc_tm(right_probe))
        if tm_diff > tm_diff_cutoff:
            # check if naive split has more acceptable Tm
            naive_left = seqrc(seq[:hyb_len])
            naive_right = seqrc(seq[hyb_len:])
            if np.abs(calc_tm(naive_left) - calc_tm(naive_right)) < tm_diff:
                left_probe = naive_left
                right_probe = naive_right
                tm_diff = np.abs(calc_tm(left_probe) - calc_tm(right_probe))
        if calc_tm(left_probe) >= abs_tm_cutoff and calc_tm(right_probe) > abs_tm_cutoff and tm_diff <= tm_diff_cutoff:
            #print(i, calc_tm(left_probe), calc_tm(right_probe))
            pbs.append( left_probe + PADLOCK_RCA_PRIMER + "N" + linker + right_probe)
    return pbs
